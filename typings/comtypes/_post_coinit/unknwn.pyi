"""
This type stub file was generated by pyright.
"""

from ctypes import c_void_p
from typing import Any, ClassVar, List, Literal, Optional, TYPE_CHECKING, Type, TypeVar, Union as _UnionT
from comtypes import GUID, hints
from comtypes._memberspec import _ComMemberSpec, _DispMemberSpec

if TYPE_CHECKING:
    ...
logger = ...
class _cominterface_meta(type):
    """Metaclass for COM interfaces.  Automatically creates high level
    methods from COMMETHOD lists.
    """
    _case_insensitive_: bool
    _iid_: GUID
    _methods_: List[_ComMemberSpec]
    _disp_methods_: List[_DispMemberSpec]
    _com_shutting_down = ...
    def __new__(cls, name, bases, namespace): # -> Self | type[<subclass of _cominterface_meta* and _compointer_base>] | type[_cominterface_meta]:
        ...
    
    def __setattr__(self, name: str, value: Any) -> None:
        ...
    


class _compointer_meta(type(c_void_p), _cominterface_meta):
    """metaclass for COM interface pointer classes"""
    ...


class _compointer_base(c_void_p, metaclass=_compointer_meta):
    "base class for COM interface pointer classes"
    if TYPE_CHECKING:
        __com_interface__: ClassVar[Type[IUnknown]]
        ...
    def __del__(self, _debug=...) -> None:
        "Release the COM refcount we own."
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        """Return the hash value of the pointer."""
        ...
    
    value = ...
    def __repr__(self) -> str:
        ...
    
    @classmethod
    def from_param(cls, value: _UnionT[None, Literal[0], hints.Self, IUnknown, hints.COMObject]) -> Any:
        """Convert 'value' into a COM pointer to the interface.

        This method accepts a COM pointer, or a COMObject/CoClass instance
        which is QueryInterface()d."""
        ...
    


_T_IUnknown = TypeVar("_T_IUnknown", bound="IUnknown")
if TYPE_CHECKING:
    class _IUnknown_Base(c_void_p, metaclass=_cominterface_meta):
        """This is workaround to avoid false-positive of static type checking.

        `IUnknown` behaves as a ctypes type, and `POINTER` can take it.
        This behavior is defined by some metaclasses in runtime.

        In runtime, this symbol in the namespace is just alias for
        `builtins.object`.
        """
        ...
    
    
else:
    ...
class IUnknown(_IUnknown_Base, metaclass=_cominterface_meta):
    """The most basic COM interface.

    Each subclasses of IUnknown must define these class attributes:

    _iid_ - a GUID instance defining the identifier of this interface

    _methods_ - a list of methods for this interface.

    The _methods_ list must in VTable order.  Methods are specified
    with STDMETHOD or COMMETHOD calls.
    """
    _case_insensitive_: ClassVar[bool] = ...
    _iid_: ClassVar[GUID] = ...
    _methods_: ClassVar[List[_ComMemberSpec]] = ...
    def QueryInterface(self, interface: Type[_T_IUnknown], iid: Optional[GUID] = ...) -> _T_IUnknown:
        """QueryInterface(interface) -> instance"""
        ...
    
    def AddRef(self) -> int:
        """Increase the internal refcount by one and return it."""
        ...
    
    def Release(self) -> int:
        """Decrease the internal refcount by one and return it."""
        ...
    



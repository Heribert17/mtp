"""
This type stub file was generated by pyright.
"""

import ctypes
from ctypes import _Pointer, c_int, c_void_p, c_wchar_p
from ctypes.wintypes import DWORD, WCHAR
from typing import Any, List, Optional, Sequence, TYPE_CHECKING, Tuple, Type, TypeVar, Union as _UnionT, overload
from comtypes import GUID, IUnknown, _CData, hints
from comtypes.automation import DISPID, VARIANT, VARIANTARG

if TYPE_CHECKING:
    ...
_CT = TypeVar("_CT", bound=_CData)
_T_IUnknown = TypeVar("_T_IUnknown", bound=IUnknown)
is_64_bit = ...
BOOL = c_int
HREFTYPE = DWORD
MEMBERID = DISPID
OLECHAR = WCHAR
PVOID = c_void_p
ULONG_PTR = ...
LPOLESTR = ...
LPCOLESTR = c_wchar_p
tagSYSKIND = c_int
SYS_WIN16 = ...
SYS_WIN32 = ...
SYS_MAC = ...
SYS_WIN64 = ...
SYSKIND = tagSYSKIND
tagREGKIND = c_int
REGKIND_DEFAULT = ...
REGKIND_REGISTER = ...
REGKIND_NONE = ...
REGKIND = tagREGKIND
tagTYPEKIND = c_int
TKIND_ENUM = ...
TKIND_RECORD = ...
TKIND_MODULE = ...
TKIND_INTERFACE = ...
TKIND_DISPATCH = ...
TKIND_COCLASS = ...
TKIND_ALIAS = ...
TKIND_UNION = ...
TKIND_MAX = ...
TYPEKIND = tagTYPEKIND
tagINVOKEKIND = c_int
INVOKE_FUNC = ...
INVOKE_PROPERTYGET = ...
INVOKE_PROPERTYPUT = ...
INVOKE_PROPERTYPUTREF = ...
INVOKEKIND = tagINVOKEKIND
tagDESCKIND = c_int
DESCKIND_NONE = ...
DESCKIND_FUNCDESC = ...
DESCKIND_VARDESC = ...
DESCKIND_TYPECOMP = ...
DESCKIND_IMPLICITAPPOBJ = ...
DESCKIND_MAX = ...
DESCKIND = tagDESCKIND
tagVARKIND = c_int
VAR_PERINSTANCE = ...
VAR_STATIC = ...
VAR_CONST = ...
VAR_DISPATCH = ...
VARKIND = tagVARKIND
tagFUNCKIND = c_int
FUNC_VIRTUAL = ...
FUNC_PUREVIRTUAL = ...
FUNC_NONVIRTUAL = ...
FUNC_STATIC = ...
FUNC_DISPATCH = ...
FUNCKIND = tagFUNCKIND
tagCALLCONV = c_int
CC_FASTCALL = ...
CC_CDECL = ...
CC_MSCPASCAL = ...
CC_PASCAL = ...
CC_MACPASCAL = ...
CC_STDCALL = ...
CC_FPFASTCALL = ...
CC_SYSCALL = ...
CC_MPWCDECL = ...
CC_MPWPASCAL = ...
CC_MAX = ...
CALLCONV = tagCALLCONV
IMPLTYPEFLAG_FDEFAULT = ...
IMPLTYPEFLAG_FSOURCE = ...
IMPLTYPEFLAG_FRESTRICTED = ...
IMPLTYPEFLAG_FDEFAULTVTABLE = ...
tagTYPEFLAGS = c_int
TYPEFLAG_FAPPOBJECT = ...
TYPEFLAG_FCANCREATE = ...
TYPEFLAG_FLICENSED = ...
TYPEFLAG_FPREDECLID = ...
TYPEFLAG_FHIDDEN = ...
TYPEFLAG_FCONTROL = ...
TYPEFLAG_FDUAL = ...
TYPEFLAG_FNONEXTENSIBLE = ...
TYPEFLAG_FOLEAUTOMATION = ...
TYPEFLAG_FRESTRICTED = ...
TYPEFLAG_FAGGREGATABLE = ...
TYPEFLAG_FREPLACEABLE = ...
TYPEFLAG_FDISPATCHABLE = ...
TYPEFLAG_FREVERSEBIND = ...
TYPEFLAG_FPROXY = ...
TYPEFLAGS = tagTYPEFLAGS
tagFUNCFLAGS = c_int
FUNCFLAG_FRESTRICTED = ...
FUNCFLAG_FSOURCE = ...
FUNCFLAG_FBINDABLE = ...
FUNCFLAG_FREQUESTEDIT = ...
FUNCFLAG_FDISPLAYBIND = ...
FUNCFLAG_FDEFAULTBIND = ...
FUNCFLAG_FHIDDEN = ...
FUNCFLAG_FUSESGETLASTERROR = ...
FUNCFLAG_FDEFAULTCOLLELEM = ...
FUNCFLAG_FUIDEFAULT = ...
FUNCFLAG_FNONBROWSABLE = ...
FUNCFLAG_FREPLACEABLE = ...
FUNCFLAG_FIMMEDIATEBIND = ...
FUNCFLAGS = tagFUNCFLAGS
tagVARFLAGS = c_int
VARFLAG_FREADONLY = ...
VARFLAG_FSOURCE = ...
VARFLAG_FBINDABLE = ...
VARFLAG_FREQUESTEDIT = ...
VARFLAG_FDISPLAYBIND = ...
VARFLAG_FDEFAULTBIND = ...
VARFLAG_FHIDDEN = ...
VARFLAG_FRESTRICTED = ...
VARFLAG_FDEFAULTCOLLELEM = ...
VARFLAG_FUIDEFAULT = ...
VARFLAG_FNONBROWSABLE = ...
VARFLAG_FREPLACEABLE = ...
VARFLAG_FIMMEDIATEBIND = ...
VARFLAGS = tagVARFLAGS
class ITypeLib(IUnknown):
    _iid_ = ...
    if TYPE_CHECKING:
        def GetTypeInfoCount(self) -> int:
            """Return the number of type informations"""
            ...
        
        def GetTypeInfo(self, index: int) -> ITypeInfo:
            """Load type info by index"""
            ...
        
        def GetTypeInfoType(self, index: int) -> int:
            """Return the TYPEKIND of type information"""
            ...
        
        def GetTypeInfoOfGuid(self, guid: GUID) -> ITypeInfo:
            """Return type information for a guid"""
            ...
        
        def GetTypeComp(self) -> ITypeComp:
            """Return an ITypeComp pointer."""
            ...
        
        def GetDocumentation(self, index: int) -> Tuple[str, Optional[str], int, Optional[str]]:
            """Return documentation for a type description."""
            ...
        
        def ReleaseTLibAttr(self, ptla: _Pointer[TLIBATTR]) -> int:
            """Release TLIBATTR"""
            ...
        
    def GetLibAttr(self) -> TLIBATTR:
        """Return type library attributes"""
        ...
    
    def IsName(self, name: str, lHashVal: int = ...) -> Optional[str]:
        """Check if there is type information for this name.

        Returns the name with capitalization found in the type
        library, or None.
        """
        ...
    
    def FindName(self, name: str, lHashVal: int = ...) -> Optional[Tuple[int, ITypeInfo]]:
        ...
    


@overload
def fix_name(name: None) -> None:
    ...

@overload
def fix_name(name: str) -> str:
    ...

def fix_name(name):
    ...

class ITypeInfo(IUnknown):
    _iid_ = ...
    if TYPE_CHECKING:
        def GetTypeComp(self) -> ITypeComp:
            """Return ITypeComp pointer for this type"""
            ...
        
        def GetRefTypeOfImplType(self, index: int) -> int:
            """Get the reftype of an implemented type"""
            ...
        
        def GetImplTypeFlags(self, index: int) -> int:
            """Get IMPLTYPEFLAGS"""
            ...
        
        def GetDllEntry(self, memid: int, invkind: int) -> Tuple[Optional[str], Optional[str], int]:
            """Return the dll name, function name, and ordinal for a function
            and invkind.
            """
            ...
        
        def GetRefTypeInfo(self, href: int) -> ITypeInfo:
            """Get type info for reftype"""
            ...
        
        def GetMops(self, index: int) -> Optional[str]:
            """Get marshalling opcodes (whatever that is...)"""
            ...
        
        def GetContainingTypeLib(self) -> Tuple[ITypeLib, int]:
            """Return index into and the containing type lib itself"""
            ...
        
        def ReleaseTypeAttr(self, pTypeAttr: _Pointer[TYPEATTR]) -> int:
            """Releases a TYPEATTR previously returned by GetTypeAttr"""
            ...
        
        def ReleaseFuncDesc(self, pFuncDesc: _Pointer[FUNCDESC]) -> int:
            """Releases a FUNCDESC previously returned by GetFuncDesc"""
            ...
        
        def ReleaseVarDesc(self, pVarDesc: _Pointer[VARDESC]) -> int:
            """Releases a VARDESC previously returned by VarDesc"""
            ...
        
    def GetTypeAttr(self) -> TYPEATTR:
        """Return the TYPEATTR for this type"""
        ...
    
    def GetDocumentation(self, memid: int) -> Tuple[str, Optional[str], int, Optional[str]]:
        """Return name, docstring, helpcontext, and helpfile for 'memid'."""
        ...
    
    def GetFuncDesc(self, index: int) -> FUNCDESC:
        """Return FUNCDESC for index"""
        ...
    
    def GetVarDesc(self, index: int) -> VARDESC:
        """Return VARDESC for index"""
        ...
    
    def GetNames(self, memid: int, count: int = ...) -> List[str]:
        """Return names for memid"""
        ...
    
    def GetIDsOfNames(self, *names: str) -> List[int]:
        """Maps function and argument names to identifiers"""
        ...
    
    def AddressOfMember(self, memid, invkind):
        """Get the address of a function in a dll"""
        ...
    
    def CreateInstance(self, punkouter: Optional[Type[_Pointer[IUnknown]]] = ..., interface: Type[_T_IUnknown] = ..., iid: Optional[GUID] = ...) -> _T_IUnknown:
        ...
    


class ITypeComp(IUnknown):
    _iid_ = ...
    def Bind(self, name: str, flags: int = ..., lHashVal: int = ...) -> Optional[Tuple[str, _UnionT[FUNCDESC, VARDESC, ITypeComp]]]:
        """Bind to a name"""
        ...
    
    def BindType(self, name: str, lHashVal: int = ...) -> Tuple[ITypeInfo, ITypeComp]:
        """Bind a type, and return both the typeinfo and typecomp for it."""
        ...
    


class ICreateTypeLib(IUnknown):
    _iid_ = ...


class ICreateTypeLib2(ICreateTypeLib):
    _iid_ = ...


class ICreateTypeInfo(IUnknown):
    _iid_ = ...
    def SetFuncAndParamNames(self, index: int, *names: str) -> int:
        ...
    


class IRecordInfo(IUnknown):
    _iid_ = ...
    def GetFieldNames(self, *args: Any) -> List[Optional[str]]:
        ...
    
    if TYPE_CHECKING:
        def RecordCopy(self, pvExisting: hints.Incomplete, pvNew: hints.Incomplete) -> hints.Hresult:
            ...
        
        def GetGuid(self) -> GUID:
            ...
        
        def GetName(self) -> str:
            ...
        
        def GetSize(self) -> int:
            ...
        
        def GetTypeInfo(self) -> ITypeInfo:
            ...
        
        def IsMatchingType(self, value: IRecordInfo) -> bool:
            ...
        
        def RecordCreateCopy(self, pvSource: hints.Incomplete) -> int:
            ...
        
        def RecordDestroy(self, pvRecord: hints.Incomplete) -> hints.Hresult:
            ...
        


_oleaut32 = ...
_GetRecordInfoFromTypeInfo = ...
_GetRecordInfoFromGuids = ...
_LoadRegTypeLib = ...
_LoadTypeLibEx = ...
_LoadTypeLib = ...
_UnRegisterTypeLib = ...
_RegisterTypeLib = ...
_CreateTypeLib2 = ...
_QueryPathOfRegTypeLib = ...
_kernel32 = ...
_GetModuleFileNameW = ...
def GetRecordInfoFromTypeInfo(tinfo: ITypeInfo) -> IRecordInfo:
    """Return an IRecordInfo pointer to the UDT described in tinfo"""
    ...

def GetRecordInfoFromGuids(rGuidTypeLib: str, verMajor: int, verMinor: int, lcid: int, rGuidTypeInfo: str) -> IRecordInfo:
    ...

def LoadRegTypeLib(guid: _UnionT[str, GUID], wMajorVerNum: int, wMinorVerNum: int, lcid: int = ...) -> ITypeLib:
    """Load a registered type library"""
    ...

def LoadTypeLibEx(szFile: str, regkind: int = ...) -> ITypeLib:
    """Load, and optionally register a type library file"""
    ...

def LoadTypeLib(szFile: str) -> ITypeLib:
    """Load and register a type library file"""
    ...

def UnRegisterTypeLib(libID: str, wVerMajor: int, wVerMinor: int, lcid: int = ..., syskind: int = ...) -> int:
    """Unregister a registered type library"""
    ...

def RegisterTypeLib(tlib: ITypeLib, fullpath: str, helpdir: Optional[str] = ...) -> int:
    """Register a type library in the registry"""
    ...

def CreateTypeLib(filename: str, syskind: int = ...) -> ICreateTypeLib2:
    """Return a ICreateTypeLib2 pointer"""
    ...

def QueryPathOfRegTypeLib(libid: str, wVerMajor: int, wVerMinor: int, lcid: int = ...) -> str:
    """
    Retrieve the path of a registered type library.

    This function interacts with the Windows registry to locate the path of a
    registered type library given its GUID, version, and locale.

    Args:
        libid (str): The GUID of the type library as a string.
        wVerMajor (int): The major version of the type library.
        wVerMinor (int): The minor version of the type library.
        lcid (int, optional): The locale ID of the type library.

    Returns:
        str: The path of the registered type library.

    Raises:
        OSError: If QueryPathOfRegTypeLib fails.
    """
    ...

def GetModuleFileName(handle: Optional[int], maxsize: int) -> str:
    """Returns the fullpath of the loaded module specified by the handle.
    If the handle is NULL, returns the executable file path of the current process.

    https://learn.microsoft.com/ja-jp/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw
    """
    ...

class tagTLIBATTR(ctypes.Structure):
    if TYPE_CHECKING:
        guid: GUID
        lcid: int
        syskind: int
        wMajorVerNum: int
        wMinorVerNum: int
        wLibFlags: int
        ...
    def __repr__(self): # -> str:
        ...
    


TLIBATTR = tagTLIBATTR
class tagTYPEATTR(ctypes.Structure):
    if TYPE_CHECKING:
        guid: GUID
        lcid: int
        dwReserved: int
        memidConstructor: int
        memidDestructor: int
        lpstrSchema: str
        cbSizeInstance: int
        typekind: int
        cFuncs: int
        cVars: int
        cImplTypes: int
        cbSizeVft: int
        cbAlignment: int
        wTypeFlags: int
        wMajorVerNum: int
        wMinorVerNum: int
        tdescAlias: TYPEDESC
        idldescType: IDLDESC
        ...
    def __repr__(self): # -> str:
        ...
    


TYPEATTR = tagTYPEATTR
class tagFUNCDESC(ctypes.Structure):
    if TYPE_CHECKING:
        memid: int
        lprgscode: int
        lprgelemdescParam: Sequence[ELEMDESC]
        funckind: int
        invkind: int
        callconv: int
        cParams: int
        cParamsOpt: int
        oVft: int
        cScodes: int
        elemdescFunc: ELEMDESC
        wFuncFlags: int
        ...
    def __repr__(self): # -> str:
        ...
    


FUNCDESC = tagFUNCDESC
class tagVARDESC(ctypes.Structure):
    if TYPE_CHECKING:
        memid: int
        lpstrSchema: str
        _: N10tagVARDESC5DOLLAR_205E
        elemdescVar: ELEMDESC
        wVarFlags: int
        varkind: int
        ...


VARDESC = tagVARDESC
class tagBINDPTR(ctypes.Union):
    if TYPE_CHECKING:
        lpfuncdesc: _Pointer[FUNCDESC]
        lpvardesc: _Pointer[VARDESC]
        lptcomp: ITypeComp
        ...


BINDPTR = tagBINDPTR
class tagTYPEDESC(ctypes.Structure):
    if TYPE_CHECKING:
        _: N11tagTYPEDESC5DOLLAR_203E
        vt: int
        ...


TYPEDESC = tagTYPEDESC
class tagIDLDESC(ctypes.Structure):
    if TYPE_CHECKING:
        dwReserved: int
        wIDLFlags: int
        ...


IDLDESC = tagIDLDESC
class tagARRAYDESC(ctypes.Structure):
    if TYPE_CHECKING:
        tdescElem: TYPEDESC
        cDims: int
        rgbounds: Sequence[SAFEARRAYBOUND]
        ...


class IProvideClassInfo(IUnknown):
    _iid_ = ...
    if TYPE_CHECKING:
        def GetClassInfo(self) -> ITypeInfo:
            """Returns the ITypeInfo interface for the object's coclass type
            information.
            """
            ...
        
    _methods_ = ...


GUIDKIND_DEFAULT_SOURCE_DISP_IID = ...
class IProvideClassInfo2(IProvideClassInfo):
    _iid_ = ...
    if TYPE_CHECKING:
        def GetGUID(self, dwGuidKind: int) -> GUID:
            """Returns the GUID for the object's outgoing IID for its default
            event set
            """
            ...
        
    _methods_ = ...


class N11tagTYPEDESC5DOLLAR_203E(ctypes.Union):
    if TYPE_CHECKING:
        lptdesc: _Pointer[tagTYPEDESC]
        lpadesc: _Pointer[tagARRAYDESC]
        hreftype: int
        ...


class N10tagVARDESC5DOLLAR_205E(ctypes.Union):
    if TYPE_CHECKING:
        oInst: int
        lpvarValue: _Pointer[VARIANT]
        ...


class tagELEMDESC(ctypes.Structure):
    if TYPE_CHECKING:
        tdesc: TYPEDESC
        _: N11tagELEMDESC5DOLLAR_204E
        ...


class N11tagELEMDESC5DOLLAR_204E(ctypes.Union):
    if TYPE_CHECKING:
        idldesc: IDLDESC
        paramdesc: PARAMDESC
        ...


class tagPARAMDESC(ctypes.Structure):
    if TYPE_CHECKING:
        pparamdescex: _Pointer[tagPARAMDESCEX]
        wParamFlags: int
        ...


class tagPARAMDESCEX(ctypes.Structure):
    if TYPE_CHECKING:
        cBytes: int
        varDefaultValue: VARIANTARG
        ...


LPPARAMDESCEX = ...
PARAMDESC = tagPARAMDESC
ELEMDESC = tagELEMDESC
class tagSAFEARRAYBOUND(ctypes.Structure):
    if TYPE_CHECKING:
        cElements: int
        lLbound: int
        ...
    _fields_ = ...


SAFEARRAYBOUND = tagSAFEARRAYBOUND
__known_symbols__ = ...

"""
This type stub file was generated by pyright.
"""

from typing import Mapping, Optional, Set, Tuple, Union as _UnionT, overload

class ImportedNamespaces:
    def __init__(self) -> None:
        ...
    
    @overload
    def add(self, modulename: str, /) -> None:
        ...
    
    @overload
    def add(self, modulename: str, symbolname: str, /) -> None:
        ...
    
    @overload
    def add(self, symbolname: str, /, *, symbols: Mapping[str, str]) -> None:
        ...
    
    def add(self, name1: str, name2: Optional[str] = ..., symbols: Optional[Mapping[str, str]] = ...) -> None:
        """Adds a namespace will be imported.

        Examples:
            >>> imports = ImportedNamespaces()
            >>> imports.add('datetime')
            >>> imports.add('ctypes', '*')
            >>> imports.add('decimal', 'Decimal')
            >>> imports.add('GUID', symbols={'GUID': 'comtypes'})
            >>> for name in ('COMMETHOD', 'DISPMETHOD', 'IUnknown', 'dispid',
            ...              'CoClass', 'BSTR', 'DISPPROPERTY'):
            ...     imports.add('comtypes', name)
            >>> imports.add('ctypes.wintypes')
            >>> print(imports.getvalue())
            from ctypes import *
            import datetime
            from decimal import Decimal
            from comtypes import (
                BSTR, CoClass, COMMETHOD, dispid, DISPMETHOD, DISPPROPERTY, GUID,
                IUnknown
            )
            import ctypes.wintypes
            >>> assert imports.get_symbols() == {
            ...     'Decimal', 'GUID', 'COMMETHOD', 'DISPMETHOD', 'IUnknown',
            ...     'dispid', 'CoClass', 'BSTR', 'DISPPROPERTY'
            ... }
        """
        ...
    
    def __contains__(self, item: _UnionT[str, Tuple[str, str]]) -> bool:
        """Returns item has already added.

        Examples:
            >>> imports = ImportedNamespaces()
            >>> imports.add('datetime')
            >>> imports.add('ctypes', '*')
            >>> 'datetime' in imports
            True
            >>> ('ctypes', '*') in imports
            True
            >>> 'os' in imports
            False
            >>> 'ctypes' in imports
            False
            >>> ('ctypes', 'c_int') in imports
            False
        """
        ...
    
    def get_symbols(self) -> Set[str]:
        ...
    
    def getvalue(self) -> str:
        ...
    


class DeclaredNamespaces:
    def __init__(self) -> None:
        ...
    
    def add(self, alias: str, definition: str, comment: Optional[str] = ...) -> None:
        """Adds a namespace will be declared.

        Examples:
            >>> declarations = DeclaredNamespaces()
            >>> declarations.add('STRING', 'c_char_p')
            >>> declarations.add('_lcid', '0', 'change this if required')
            >>> print(declarations.getvalue())
            STRING = c_char_p
            _lcid = 0  # change this if required
            >>> assert declarations.get_symbols() == {
            ...     'STRING', '_lcid'
            ... }
        """
        ...
    
    def get_symbols(self) -> Set[str]:
        ...
    
    def getvalue(self) -> str:
        ...
    


class EnumerationNamespaces:
    def __init__(self) -> None:
        ...
    
    def add(self, enum_name: str, member_name: str, value: int) -> None:
        """Adds a namespace will be enumeration and its member.

        Examples:
            <BLANKLINE> is necessary for doctest
            >>> enums = EnumerationNamespaces()
            >>> assert not enums
            >>> enums.add('Foo', 'ham', 1)
            >>> assert enums
            >>> enums.add('Foo', 'spam', 2)
            >>> enums.add('Bar', 'bacon', 3)
            >>> enums.add('Bar', 'egg', 4)
            >>> import warnings
            >>> with warnings.catch_warnings(record=True) as w:
            ...     enums.add('Bar', 'egg', 5)
            ...     print(w[-1].message.args[0].replace(', ', ',\\n'))
            The 'egg' member of the 'Bar' enumeration is already assigned 4,
            but it will be overwritten with 5,
            based on the type information.
            >>> assert 'Foo' in enums
            >>> assert 'Baz' not in enums
            >>> print(enums.to_intflags())
            class Foo(IntFlag):
                ham = 1
                spam = 2
            <BLANKLINE>
            <BLANKLINE>
            class Bar(IntFlag):
                bacon = 3
                # egg = 4  # duplicated. Perhaps there is a bug in the type library?
                egg = 5  # duplicated. Perhaps there is a bug in the type library?
            >>> print(enums.to_constants())
            # values for enumeration 'Foo'
            ham = 1
            spam = 2
            Foo = c_int  # enum
            <BLANKLINE>
            # values for enumeration 'Bar'
            bacon = 3
            egg = 4  # duplicated within the 'Bar'. Perhaps there is a bug?
            egg = 5  # duplicated within the 'Bar'. Perhaps there is a bug?
            Bar = c_int  # enum
        """
        ...
    
    def __contains__(self, item: str) -> bool:
        ...
    
    def __bool__(self) -> bool:
        ...
    
    def get_symbols(self) -> Set[str]:
        ...
    
    def to_constants(self) -> str:
        ...
    
    def to_intflags(self) -> str:
        ...
    


